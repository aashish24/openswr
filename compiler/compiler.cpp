// Copyright 2014 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#if defined(_WIN32)
#pragma warning(disable : 4800 4146 4244 4267 4355 4996)
#endif

#include "api.h"
#include "compiler.h"
#include "containers.hpp"
#include "GPUFPMath.h"
#include "PtWise.h"
#include "Simtize.h"

#include <bitset>
#include <cstdio>
#include <map>
#include <set>
#include <string>
#include <vector>

#include "llvm/IR/DataLayout.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/PassManager.h"

#include "llvm/Config/config.h"
#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR >= 5)
#include "llvm/IR/Verifier.h"
#else
#include "llvm/Analysis/Verifier.h"
#endif

#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR >= 4)
#include "llvm/Support/FileSystem.h"
#define LLVM_F_NONE sys::fs::F_None
#else
#define LLVM_F_NONE 0
#endif

#include "llvm/Analysis/Passes.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/JITEventListener.h"
#include "llvm/ExecutionEngine/MCJIT.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Transforms/IPO.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Support/Host.h"

using namespace llvm;

// This holds the LLVM data structures.
// Contains LLVM mContext/mModule executable page cache. Executable pages are generated by LLVM. LLVM fills this with executable code and returns the pointer.
// mContext - contains the LLVM compiler
// mModule - contains the LLVM executable page cache and instances of LLVM IR functions, etc.
// mBuilder - Convenience module for building LLVM functions.
// mScalarPasses/mVectorPasses - standard LLVM out-of-box passes for scalar/vector code generation.
// mPtWise - Let's us do pseudo LLVM operations on data structures. Add 2 structs (e.g. add all the fields individually) done in a PtWise.
struct ShG
{
    ShG(UINT w)
        : mContext(), mBuilder(mContext), mPtWise(mBuilder),
          mModule(NULL), mSetupPasses(NULL), mScalarPasses(NULL), mVectorPasses(NULL),
          mVWidth(w), mFuncCount(0)
    {
        InitializeNativeTarget();
        InitializeNativeTargetAsmPrinter();
        InitializeAllDisassemblers();

        mFP32Ty = Type::getFloatTy(mContext);                                            // float type
        mInt32Ty = Type::getInt32Ty(mContext);                                           // int type
        mInt64Ty = Type::getInt64Ty(mContext);                                           // int type
        mV4FP32Ty = StructType::get(mContext, std::vector<Type *>(4, mFP32Ty), false);   // vector4 float type (represented as structure)
        mV4Int32Ty = StructType::get(mContext, std::vector<Type *>(4, mInt32Ty), false); // vector4 int type

        // Input register file. (e.g. VERTEXINPUT)
        mSlotsTy = ArrayType::get(mV4FP32Ty, VS_SLOT_MAX); // todo Rename VS_SLOT_MAX to something more generic as this is used for PS too.
        std::vector<Type *> vtxinelts;                     // Field types of the input structure
        vtxinelts.push_back(mSlotsTy);
        // The practical way to represent a void* is pointer to empty struct in address space 0. Address spaces are not allowed to mixed.
        vtxinelts.push_back(PointerType::get(StructType::get(mContext), /* address space 0 */ 0)); // opaque type (pConstants)
        vtxinelts.push_back(PointerType::get(StructType::get(mContext), 0));                       // opaque type (pAttribs)

        mVsInputTy = StructType::get(mContext, vtxinelts, false); // scalar input for SWRC. VERTEXINPUT in scalar.
        mVInputTy = SimtizeType(&mContext, mVWidth, mVsInputTy);  // vector input for SWRC. VERTEXINPUT in vector form. Only consumed by LLVM.

        // Description of the output (VTXOUTPUT)
        std::vector<Type *> vtxoutelts;
        vtxoutelts.push_back(mSlotsTy);
        vtxoutelts.push_back(PointerType::get(StructType::get(mContext), 0)); // opaque type (pVertices)
        vtxoutelts.push_back(PointerType::get(StructType::get(mContext), 0)); // opaque type (pAttribs)

        mVsOutputTy = StructType::get(mContext, vtxoutelts, false);

        std::vector<Type *> vsArgs;
        vsArgs.push_back(PointerType::get(mVsInputTy, 0));
        vsArgs.push_back(PointerType::get(mVsOutputTy, 0));

        // Shader kernel type. The function pointer to the shader. (e.g. typedef void(*PFN_VERTEX_FUNC)(const VERTEXINPUT& in, VERTEXOUTPUT& out);)
        mpfnTy = FunctionType::get(Type::getVoidTy(mContext), vsArgs, false);

        std::vector<Type *> pixinelts;
#if KNOB_VERTICALIZED_BE
        char VERTICALIZED_BE_IS_NOT_SUPPORTED_IN_PS[-1];
#else
        // This describes "struct SWR_TRIANGLE_DESC". Horizontal version.
        pixinelts.push_back(ArrayType::get(Type::getFloatTy(mContext), 4));  // I
        pixinelts.push_back(ArrayType::get(Type::getFloatTy(mContext), 4));  // J
        pixinelts.push_back(ArrayType::get(Type::getFloatTy(mContext), 4));  // Z
        pixinelts.push_back(ArrayType::get(Type::getFloatTy(mContext), 4));  // OneOverW
        pixinelts.push_back(Type::getFloatTy(mContext));                     // zStepX
        pixinelts.push_back(Type::getFloatTy(mContext));                     // zStepY
        pixinelts.push_back(Type::getFloatTy(mContext));                     // recipDet
        pixinelts.push_back(PointerType::get(StructType::get(mContext), 0)); // pInterpBuffer
        pixinelts.push_back(Type::getInt32Ty(mContext));                     // tileX
        pixinelts.push_back(Type::getInt32Ty(mContext));                     // tileY
        pixinelts.push_back(Type::getInt32Ty(mContext));                     // widthInBytes
        pixinelts.push_back(Type::getInt64Ty(mContext));                     // coverageMask
        pixinelts.push_back(PointerType::get(StructType::get(mContext), 0)); // pConstants
        pixinelts.push_back(PointerType::get(StructType::get(mContext), 0)); // opaque 0
        pixinelts.push_back(PointerType::get(StructType::get(mContext), 0)); // opaque 1
#endif
        mPsInputTy = StructType::get(mContext, pixinelts, false);

        std::vector<Type *> pixoutelts;
#if KNOB_VERTICALIZED_BE
        char VERTICALIZED_BE_IS_NOT_SUPPORTED_IN_PS[-1];
#else
        pixoutelts.push_back(ArrayType::get(PointerType::get(StructType::get(mContext), 0), KNOB_NUM_RENDERTARGETS));
#endif
        mPsOutputTy = StructType::get(mContext, pixoutelts, false);

        std::vector<Type *> psArgs;
        psArgs.push_back(PointerType::get(mPsInputTy, 0));
        psArgs.push_back(PointerType::get(mPsOutputTy, 0));

        mPSShaderTy = FunctionType::get(Type::getVoidTy(mContext), psArgs, false);

        std::vector<Type *> ftchelts;
        ftchelts.push_back(ArrayType::get(Type::getInt8PtrTy(mContext), KNOB_NUM_STREAMS)); // streams
        ftchelts.push_back(PointerType::get(mInt32Ty, 0));                                  // indices
        ftchelts.push_back(PointerType::get(mFP32Ty, 0));                                   // constants; streams of floats

        mFetchInfoTy = StructType::get(mContext, ftchelts, false);

        std::vector<Type *> fsArgs;
        fsArgs.push_back(PointerType::get(mFetchInfoTy, 0));
        fsArgs.push_back(PointerType::get(mVInputTy, 0));

        mFetchShaderTy = FunctionType::get(Type::getVoidTy(mContext), fsArgs, false);

        // Metadata - This is how simtize works. Scalarization pass.
        mSimtizeDont = MDString::get(mContext, SimtizeMetadataDont());
        mSimtize = MDString::get(mContext, SimtizeMetadataSimtize());
        mSimtizeBroadcast = MDString::get(mContext, SimtizeMetadataBroadcast());
        mBroadcastMDName = SimtizeMetadataName();
    }

    void InitializeModule()
    {
        delete mModule; // execution engine holds a reference
        delete mSetupPasses;
        delete mScalarPasses;
        delete mVectorPasses;

        mModule = new Module("shaders", mContext);
        mSetupPasses = new FunctionPassManager(mModule);
        mScalarPasses = new FunctionPassManager(mModule);
        mVectorPasses = new FunctionPassManager(mModule);

        TargetOptions tOpts;
        tOpts.AllowFPOpFusion = FPOpFusion::Fast;
        tOpts.NoInfsFPMath = true;
        tOpts.NoNaNsFPMath = true;
        tOpts.UnsafeFPMath = true;

#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR >= 6)
        auto EB = EngineBuilder(std::unique_ptr<llvm::Module>(mModule));
#else
        auto EB = EngineBuilder(mModule);
        EB.setUseMCJIT(true);
#endif
        EB.setTargetOptions(tOpts);
        EB.setOptLevel(CodeGenOpt::Aggressive);
        EB.setMCPU(sys::getHostCPUName());
        mpExec = EB.create();

#if LLVM_USE_INTEL_JITEVENTS
        JITEventListener *vTune = JITEventListener::createIntelJITEventListener();
        mpExec->RegisterJITEventListener(vTune);
#endif

        // 1. Setup pass which is program structure
        //mSetupPasses.add(new DataLayout(*mpExec->getDataLayout()));
        mSetupPasses->add(createBreakCriticalEdgesPass());
        mSetupPasses->add(createCFGSimplificationPass());

        mSetupPasses->add(createEarlyCSEPass());
        mSetupPasses->add(createPromoteMemoryToRegisterPass());

        // 2. scalar passes
        mScalarPasses->add(createEarlyCSEPass());
        mScalarPasses->add(createInstructionCombiningPass());
        mScalarPasses->add(createInstructionSimplifierPass());
        mScalarPasses->add(createIgnoreTheAnnoyingPartsOfTheIEEE754SpecPass(false));
        mScalarPasses->add(createConstantPropagationPass());
        mScalarPasses->add(createSCCPPass());
        mScalarPasses->add(createAggressiveDCEPass());

        // 3. vector passes
        mVectorPasses->add(createSROAPass()); // scalar replacement of aggregate. Structures are split into scalars and operates on them as scalars.
        mVectorPasses->add(createEarlyCSEPass());
        mVectorPasses->add(createInstructionCombiningPass());
        mVectorPasses->add(createInstructionSimplifierPass());
        // This is for floating point optimizations. Do not need strict rules because OGL1 does not require this.
        // Worked with Craig Topper on this. (x * 0 = 0)
        mVectorPasses->add(createIgnoreTheAnnoyingPartsOfTheIEEE754SpecPass(false));
        mVectorPasses->add(createConstantPropagationPass());
        mVectorPasses->add(createSCCPPass());
        mVectorPasses->add(createAggressiveDCEPass());

        // Add intrinsics.
        FunctionType *UnaryFPTy = FunctionType::get(mFP32Ty, std::vector<Type *>(1, mFP32Ty), false);
        FunctionType *BinaryFPTy = FunctionType::get(mFP32Ty, std::vector<Type *>(2, mFP32Ty), false);
        FunctionType *TrinaryFPTy = FunctionType::get(mFP32Ty, std::vector<Type *>(3, mFP32Ty), false);
        FunctionType *BinaryIntTy = FunctionType::get(mInt32Ty, std::vector<Type *>(2, mInt32Ty), false);

        Type *SimtFP32Ty = VectorType::get(mFP32Ty, mVWidth);
        Type *SimtInt32Ty = VectorType::get(mInt32Ty, mVWidth);

        FunctionType *V4UnaryFPTy = FunctionType::get(SimtFP32Ty, std::vector<Type *>(1, SimtFP32Ty), false);
        FunctionType *V4BinaryFPTy = FunctionType::get(SimtFP32Ty, std::vector<Type *>(2, SimtFP32Ty), false);
        FunctionType *V4TrinaryFPTy = FunctionType::get(SimtFP32Ty, std::vector<Type *>(3, SimtFP32Ty), false);
        FunctionType *V4BinaryIntTy = FunctionType::get(SimtInt32Ty, std::vector<Type *>(2, SimtInt32Ty), false);

        mSqrt = Function::Create(UnaryFPTy, GlobalValue::ExternalLinkage, "swrc.sqrt.f32", mModule);
        mSqrt->addFnAttr(Attribute::NoUnwind);
        mSqrt->addFnAttr(Attribute::ReadNone);
        mRcp = Function::Create(UnaryFPTy, GlobalValue::ExternalLinkage, "swrc.rcp.f32", mModule);
        mRcp->addFnAttr(Attribute::NoUnwind);
        mRcp->addFnAttr(Attribute::ReadNone);
        mRSqrt = Function::Create(UnaryFPTy, GlobalValue::ExternalLinkage, "swrc.rsqrt.f32", mModule);
        mRSqrt->addFnAttr(Attribute::NoUnwind);
        mRSqrt->addFnAttr(Attribute::ReadNone);
        mMin = Function::Create(BinaryIntTy, GlobalValue::ExternalLinkage, "swrc.min.i32", mModule);
        mMin->addFnAttr(Attribute::NoUnwind);
        mMin->addFnAttr(Attribute::ReadNone);
        mFMin = Function::Create(BinaryFPTy, GlobalValue::ExternalLinkage, "swrc.min.f32", mModule);
        mFMin->addFnAttr(Attribute::NoUnwind);
        mFMin->addFnAttr(Attribute::ReadNone);
        mMax = Function::Create(BinaryIntTy, GlobalValue::ExternalLinkage, "swrc.max.i32", mModule);
        mMax->addFnAttr(Attribute::NoUnwind);
        mMax->addFnAttr(Attribute::ReadNone);
        mFMax = Function::Create(BinaryFPTy, GlobalValue::ExternalLinkage, "swrc.max.f32", mModule);
        mFMax->addFnAttr(Attribute::NoUnwind);
        mFMax->addFnAttr(Attribute::ReadNone);
        mFloor = Function::Create(UnaryFPTy, GlobalValue::ExternalLinkage, "swrc.floor.f32", mModule);
        mFloor->addFnAttr(Attribute::NoUnwind);
        mFloor->addFnAttr(Attribute::ReadNone);
        mFAbs = Function::Create(UnaryFPTy, GlobalValue::ExternalLinkage, "swrc.abs.f32", mModule);
        mFAbs->addFnAttr(Attribute::NoUnwind);
        mFAbs->addFnAttr(Attribute::ReadNone);
        mFMA = Function::Create(TrinaryFPTy, GlobalValue::ExternalLinkage, "swrc.fmuladd.f32", mModule);
        mFMA->addFnAttr(Attribute::NoUnwind);
        mFMA->addFnAttr(Attribute::ReadNone);

        // This is the way we do intrinsics.
        mSimtFunctionMap[mSqrt] = Function::Create(V4UnaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.sqrt.ps" : "llvm.x86.avx.sqrt.ps.256", mModule);
        mSimtFunctionMap[mRcp] = Function::Create(V4UnaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.rcp.ps" : "llvm.x86.avx.rcp.ps.256", mModule);
        mSimtFunctionMap[mRSqrt] = Function::Create(V4UnaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.rsqrt.ps" : "llvm.x86.avx.rsqrt.ps.256", mModule);
        mSimtFunctionMap[mMin] = Function::Create(V4BinaryIntTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.min.epi32" : "llvm.x86.avx.min.epi32.256", mModule);
        mSimtFunctionMap[mFMin] = Function::Create(V4BinaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.min.ps" : "llvm.x86.avx.min.ps.256", mModule);
        mSimtFunctionMap[mMax] = Function::Create(V4BinaryIntTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.max.epi32" : "llvm.x86.avx.max.epi32.256", mModule);
        mSimtFunctionMap[mFMax] = Function::Create(V4BinaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.x86.sse.max.ps" : "llvm.x86.avx.max.ps.256", mModule);
        mSimtFunctionMap[mFloor] = Function::Create(V4UnaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.floor.v4f32" : "llvm.floor.v8f32", mModule);
        mSimtFunctionMap[mFAbs] = Function::Create(V4UnaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.abs.v4f32" : "llvm.abs.v8f32", mModule);
        mSimtFunctionMap[mFMA] = Function::Create(V4TrinaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.fmuladd.v4f32" : "llvm.fmuladd.v8f32", mModule);
        mSimtFunctionMap[mFAbs] = Function::Create(V4BinaryFPTy, GlobalValue::ExternalLinkage, mVWidth == 4 ? "llvm.fabs.v4f32" : "llvm.fabs.v8f32", mModule);
    }

    LLVMContext mContext;
    IRBuilder<> mBuilder;
    PtWiseBuilder<> mPtWise;

    Module *mModule;
    ExecutionEngine *mpExec;
    FunctionPassManager *mSetupPasses;
    FunctionPassManager *mScalarPasses;
    FunctionPassManager *mVectorPasses;
    ValueMap<Function *, Function *> mSimtFunctionMap;

    UINT mVWidth;

    unsigned mFuncCount;

    // Built in functions.
    Function *mSqrt;
    Function *mRcp;
    Function *mRSqrt;
    Function *mCos;
    Function *mSin;
    Function *mLog2;
    Function *mLn;
    Function *mExp;
    Function *mPow;
    Function *mMin;
    Function *mFMin;
    Function *mMax;
    Function *mFMax;
    Function *mFloor;
    Function *mFAbs;
    Function *mFMA;
    Function *mFMS;
#if !defined(_WIN32)
    Function *mF4TrF32;
    Function *mF4TrI32;
#endif
    // Built in types.
    Type *mInt32Ty;
    Type *mInt64Ty;
    Type *mFP32Ty;
    StructType *mV4FP32Ty;
    StructType *mV4Int32Ty;
    Type *mSlotsTy;
    Type *mVInputTy;
    Type *mVsInputTy;  // XXX: rename to "KnlInputTy"
    Type *mVsOutputTy; // XXX: rename to "KnlOutputTy"
    Type *mPsInputTy;
    Type *mPsOutputTy;
    Type *mFetchInfoTy;
    FunctionType *mpfnTy;         // VS & PS kernel
    FunctionType *mPSShaderTy;    // PS outer shader
    FunctionType *mFetchShaderTy; // FS outer shader

    // Metadata.
    MDString *mSimtizeDont;
    MDString *mSimtizeBroadcast;
    MDString *mSimtize;
    const char *mBroadcastMDName;
};

struct SWRC_FETCHGEN
{
    SWRC_FETCHGEN(ShG *pShG, HANDLE hContext, UINT numElements, INPUT_ELEMENT_DESC (&inputLayout)[KNOB_NUM_ATTRIBUTES], UINT (&inputStrides)[KNOB_NUM_STREAMS], SWRC_WORDCODE contiguity, SWR_TYPE indexType)
        : mShG(pShG), mhContext(hContext), mNumElements(numElements), mIEDs(inputLayout), mVBStrides(inputStrides), mContiguity(contiguity), mIndexType(indexType)
    {
    }

    PFN_FETCH_FUNC MakePackingFetchShader()
    {
        Function *fetch = Function::Create(mShG->mFetchShaderTy, GlobalValue::ExternalLinkage,
                                           std::string("FetchShader") + std::to_string((long long)(mShG->mFuncCount++)), mShG->mModule);

        BasicBlock *entry = BasicBlock::Create(mShG->mContext, "entry", fetch);

        mShG->mBuilder.SetInsertPoint(entry);

        auto argitr = fetch->getArgumentList().begin();

        Value *fetchInfo = argitr;
        ++argitr;
        fetchInfo->setName("fetchInfo");
        Value *vtxInput = argitr;
        vtxInput->setName("vtxInput");
        std::vector<Value *> vtxInputIndices(2, ConstantInt::get(mShG->mInt32Ty, 0));
        // GEP
        vtxInput = mShG->mBuilder.CreateGEP(vtxInput, vtxInputIndices);
        vtxInput = mShG->mBuilder.CreateBitCast(vtxInput, PointerType::get(VectorType::get(mShG->mFP32Ty, mShG->mVWidth), 0));

        std::vector<Value *> strIdcs;
        strIdcs.push_back(ConstantInt::get(mShG->mInt32Ty, 0, false));
        strIdcs.push_back(ConstantInt::get(mShG->mInt32Ty, 0, false));
        Value *streams = mShG->mBuilder.CreateGEP(fetchInfo, strIdcs);
        streams = mShG->mBuilder.CreateLoad(streams, false); // (float*[])
        streams->setName("streams");
        std::vector<Value *> idxIdcs;
        idxIdcs.push_back(ConstantInt::get(mShG->mInt32Ty, 0, false));
        idxIdcs.push_back(ConstantInt::get(mShG->mInt32Ty, 1, false));
        Value *indices = mShG->mBuilder.CreateGEP(fetchInfo, idxIdcs);
        indices = mShG->mBuilder.CreateLoad(indices, false);

        if (mContiguity == SWRC_DISCONTIGUOUS_IB)
        {
            switch (mIndexType)
            {
            case SWR_TYPE_UINT16:
                indices = mShG->mBuilder.CreateBitCast(indices, Type::getInt16PtrTy(mShG->mContext, 0));
                break;
            case SWR_TYPE_UINT32:
                break; // incoming type is already 32bit int
            default:
                assert(0 && "Unsupported index type");
            }
        }

        indices->setName("indices");
        std::vector<Value *> cnstIdcs;
        cnstIdcs.push_back(ConstantInt::get(mShG->mInt32Ty, 0, false));
        cnstIdcs.push_back(ConstantInt::get(mShG->mInt32Ty, 2, false));
        Value *constants = mShG->mBuilder.CreateGEP(fetchInfo, cnstIdcs);
        constants = mShG->mBuilder.CreateLoad(constants, false);
        constants->setName("constants");

        // Zack shuffles; a variant of the Charleston.

        SWRL::UncheckedFixedVector<Value *, 16> vectors;

        std::vector<Constant *> pMask(mShG->mVWidth);
        for (UINT i = 0; i < mShG->mVWidth; ++i)
        {
            pMask[i] = ConstantInt::get(mShG->mInt32Ty, i < 4 ? i : 4);
        }
        Constant *promoteMask = ConstantVector::get(pMask);
        Constant *uwvec = UndefValue::get(VectorType::get(mShG->mFP32Ty, 4));

        UINT constBufOffset = 0;

        for (UINT nelt = 0; nelt < mNumElements; ++nelt)
        {
            Value *elements[4] = { 0 };
            auto &ied = mIEDs[nelt];
            UINT numComponents = SwrNumComponents((SWR_FORMAT)ied.Format);
            SWR_TYPE type = SwrFormatType((SWR_FORMAT)ied.Format);

            vectors.clear();

            // pull the input from the constant buffer
            if (ied.Constant)
            {
                // Get offset of constant buf
                Value *indexP = mShG->mBuilder.CreateGEP(constants, ConstantInt::get(mShG->mInt32Ty, constBufOffset));
                constBufOffset += 4;

                // cast to vec4
                indexP = mShG->mBuilder.CreateBitCast(indexP, PointerType::get(VectorType::get(mShG->mFP32Ty, 4), 0));

                // 4-wide load
                indexP = mShG->mBuilder.CreateAlignedLoad(indexP, 1, false);

                Value *wvec = mShG->mBuilder.CreateShuffleVector(indexP, uwvec, promoteMask);
                for (UINT lane = 0; lane < mShG->mVWidth; ++lane)
                {
                    vectors.push_back(wvec);
                }
            }
            else
            {
                // Load from the stream.
                for (UINT lane = 0; lane < mShG->mVWidth; ++lane)
                {
                    Value *index = GetIndex(lane, indices);
                    Value *stream = mShG->mBuilder.CreateExtractValue(streams, std::vector<UINT>(1, ied.StreamIndex));

                    Value *offset = mShG->mBuilder.CreateMul(index, ConstantInt::get(mShG->mInt64Ty, mVBStrides[ied.StreamIndex]));
                    offset = mShG->mBuilder.CreateAdd(offset, ConstantInt::get(mShG->mInt64Ty, ied.AlignedByteOffset));
                    Value *pointer = mShG->mBuilder.CreateGEP(stream, offset);
                    // We use a full-lane, but don't actually care.
                    Value *vptr = 0;

                    switch (type)
                    {
                    case SWR_TYPE_FLOAT:
                        vptr = mShG->mBuilder.CreateBitCast(pointer, PointerType::get(VectorType::get(mShG->mFP32Ty, 4), 0));
                        break;
                    case SWR_TYPE_UNORM8:
                        vptr = mShG->mBuilder.CreateBitCast(pointer, PointerType::get(VectorType::get(Type::getInt8Ty(mShG->mContext), 4), 0));
                        break;
                    case SWR_TYPE_SNORM8:
                        vptr = mShG->mBuilder.CreateBitCast(pointer, PointerType::get(VectorType::get(Type::getInt8Ty(mShG->mContext), 4), 0));
                        break;
                    case SWR_TYPE_UNORM16:
                        vptr = mShG->mBuilder.CreateBitCast(pointer, PointerType::get(VectorType::get(Type::getInt16Ty(mShG->mContext), 4), 0));
                        break;
                    case SWR_TYPE_SNORM16:
                        vptr = mShG->mBuilder.CreateBitCast(pointer, PointerType::get(VectorType::get(Type::getInt16Ty(mShG->mContext), 4), 0));
                        break;
                    case SWR_TYPE_SINT16:
                        vptr = mShG->mBuilder.CreateBitCast(pointer, PointerType::get(VectorType::get(Type::getInt16Ty(mShG->mContext), 4), 0));
                        break;
                    default:
                        assert(false && "Unsupport underlying type!");
                    }

                    Value *vec = mShG->mBuilder.CreateAlignedLoad(vptr, 1, false);

                    switch (type)
                    {
                    case SWR_TYPE_FLOAT:
                        break;
                    case SWR_TYPE_UNORM8:
                        vec = mShG->mBuilder.CreateUIToFP(vec, VectorType::get(mShG->mFP32Ty, 4));
                        vec = mShG->mBuilder.CreateFMul(vec, ConstantVector::get(std::vector<Constant *>(4, ConstantFP::get(mShG->mFP32Ty, 1.0 / 255.0))));
                        break;
                    case SWR_TYPE_SNORM8:
                        vec = mShG->mBuilder.CreateSIToFP(vec, VectorType::get(mShG->mFP32Ty, 4));
                        vec = mShG->mBuilder.CreateFMul(vec, ConstantVector::get(std::vector<Constant *>(4, ConstantFP::get(mShG->mFP32Ty, 1.0 / 128.0))));
                        break;
                    case SWR_TYPE_UNORM16:
                        vec = mShG->mBuilder.CreateUIToFP(vec, VectorType::get(mShG->mFP32Ty, 4));
                        vec = mShG->mBuilder.CreateFMul(vec, ConstantVector::get(std::vector<Constant *>(4, ConstantFP::get(mShG->mFP32Ty, 1.0 / 65535.0))));
                    case SWR_TYPE_SNORM16:
                        vec = mShG->mBuilder.CreateSIToFP(vec, VectorType::get(mShG->mFP32Ty, 4));
                        vec = mShG->mBuilder.CreateFMul(vec, ConstantVector::get(std::vector<Constant *>(4, ConstantFP::get(mShG->mFP32Ty, 1.0 / 32768.0))));
                        break;
                    case SWR_TYPE_SINT16:
                        vec = mShG->mBuilder.CreateSIToFP(vec, VectorType::get(mShG->mFP32Ty, 4));
                        break;

                    default:
                        assert(false && "Unsupport underlying type!");
                    }

                    Value *wvec = mShG->mBuilder.CreateShuffleVector(vec, uwvec, promoteMask);
                    vectors.push_back(wvec);
                }
            }

            std::vector<Constant *> v01Mask(mShG->mVWidth);
            std::vector<Constant *> v23Mask(mShG->mVWidth);
            std::vector<Constant *> v02Mask(mShG->mVWidth);
            std::vector<Constant *> v13Mask(mShG->mVWidth);

            // Concatenate the vectors together.
            elements[0] = UndefValue::get(VectorType::get(mShG->mFP32Ty, mShG->mVWidth));
            elements[1] = UndefValue::get(VectorType::get(mShG->mFP32Ty, mShG->mVWidth));
            elements[2] = UndefValue::get(VectorType::get(mShG->mFP32Ty, mShG->mVWidth));
            elements[3] = UndefValue::get(VectorType::get(mShG->mFP32Ty, mShG->mVWidth));
            for (UINT b = 0, B = mShG->mVWidth / 4; b < B; ++b)
            {
                v01Mask[4 * b + 0] = ConstantInt::get(mShG->mInt32Ty, 0 + 4 * b);
                v01Mask[4 * b + 1] = ConstantInt::get(mShG->mInt32Ty, 1 + 4 * b);
                v01Mask[4 * b + 2] = ConstantInt::get(mShG->mInt32Ty, 0 + 4 * b + mShG->mVWidth);
                v01Mask[4 * b + 3] = ConstantInt::get(mShG->mInt32Ty, 1 + 4 * b + mShG->mVWidth);

                v23Mask[4 * b + 0] = ConstantInt::get(mShG->mInt32Ty, 2 + 4 * b);
                v23Mask[4 * b + 1] = ConstantInt::get(mShG->mInt32Ty, 3 + 4 * b);
                v23Mask[4 * b + 2] = ConstantInt::get(mShG->mInt32Ty, 2 + 4 * b + mShG->mVWidth);
                v23Mask[4 * b + 3] = ConstantInt::get(mShG->mInt32Ty, 3 + 4 * b + mShG->mVWidth);

                v02Mask[4 * b + 0] = ConstantInt::get(mShG->mInt32Ty, 0 + 4 * b);
                v02Mask[4 * b + 1] = ConstantInt::get(mShG->mInt32Ty, 2 + 4 * b);
                v02Mask[4 * b + 2] = ConstantInt::get(mShG->mInt32Ty, 0 + 4 * b + mShG->mVWidth);
                v02Mask[4 * b + 3] = ConstantInt::get(mShG->mInt32Ty, 2 + 4 * b + mShG->mVWidth);

                v13Mask[4 * b + 0] = ConstantInt::get(mShG->mInt32Ty, 1 + 4 * b);
                v13Mask[4 * b + 1] = ConstantInt::get(mShG->mInt32Ty, 3 + 4 * b);
                v13Mask[4 * b + 2] = ConstantInt::get(mShG->mInt32Ty, 1 + 4 * b + mShG->mVWidth);
                v13Mask[4 * b + 3] = ConstantInt::get(mShG->mInt32Ty, 3 + 4 * b + mShG->mVWidth);

                std::vector<Constant *> iMask(mShG->mVWidth);
                for (UINT i = 0; i < mShG->mVWidth; ++i)
                {
                    if (((4 * b) <= i) && (i < (4 * (b + 1))))
                    {
                        iMask[i] = ConstantInt::get(mShG->mInt32Ty, i % 4 + mShG->mVWidth);
                    }
                    else
                    {
                        iMask[i] = ConstantInt::get(mShG->mInt32Ty, i);
                    }
                }
                Constant *insertMask = ConstantVector::get(iMask);
                elements[0] = mShG->mBuilder.CreateShuffleVector(elements[0], vectors[4 * b + 0], insertMask);
                elements[1] = mShG->mBuilder.CreateShuffleVector(elements[1], vectors[4 * b + 1], insertMask);
                elements[2] = mShG->mBuilder.CreateShuffleVector(elements[2], vectors[4 * b + 2], insertMask);
                elements[3] = mShG->mBuilder.CreateShuffleVector(elements[3], vectors[4 * b + 3], insertMask);
            }

            Value *x0y0x1y1 = mShG->mBuilder.CreateShuffleVector(elements[0], elements[1], ConstantVector::get(v01Mask));
            Value *x2y2x3y3 = mShG->mBuilder.CreateShuffleVector(elements[2], elements[3], ConstantVector::get(v01Mask));
            Value *z0w0z1w1 = mShG->mBuilder.CreateShuffleVector(elements[0], elements[1], ConstantVector::get(v23Mask));
            Value *z2w3z2w3 = mShG->mBuilder.CreateShuffleVector(elements[2], elements[3], ConstantVector::get(v23Mask));
            elements[0] = mShG->mBuilder.CreateShuffleVector(x0y0x1y1, x2y2x3y3, ConstantVector::get(v02Mask));
            elements[1] = mShG->mBuilder.CreateShuffleVector(x0y0x1y1, x2y2x3y3, ConstantVector::get(v13Mask));
            elements[2] = mShG->mBuilder.CreateShuffleVector(z0w0z1w1, z2w3z2w3, ConstantVector::get(v02Mask));
            elements[3] = mShG->mBuilder.CreateShuffleVector(z0w0z1w1, z2w3z2w3, ConstantVector::get(v13Mask));

            switch (numComponents + 1)
            {
            case 1:
                elements[0] = ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantFP::get(mShG->mFP32Ty, 0.0)));
            case 2:
                elements[1] = ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantFP::get(mShG->mFP32Ty, 0.0)));
            case 3:
                elements[2] = ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantFP::get(mShG->mFP32Ty, 0.0)));
            case 4:
                elements[3] = ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantFP::get(mShG->mFP32Ty, 1.0)));
            }

            for (UINT c = 0; c < 4; ++c)
            {
                UINT slot = 0;
                switch (ied.Semantic)
                {
                case POSITION:
                    slot = VS_SLOT_POSITION;
                    break;
                case NORMAL:
                    slot = VS_SLOT_NORMAL;
                    break;
                case COLOR:
                    slot = VS_SLOT_COLOR0;
                    break;
                case TEXCOORD:
                    slot = VS_SLOT_TEXCOORD0;
                    break;
                default:
                    assert(false && "That attribute is not supported.");
                }
                slot += ied.SemanticIndex;
                Value *dest = mShG->mBuilder.CreateGEP(vtxInput, ConstantInt::get(mShG->mInt32Ty, slot * 4 + c), "destGEP");
                mShG->mBuilder.CreateStore(elements[c], dest);
            }
        }

        mShG->mBuilder.CreateRetVoid();

#if defined(KNOB_SWRC_TRACING)
        std::string err;
        char fName[1024];
        const char *funcName = fetch->getName().data();
        sprintf(fName, "%s.ll", funcName);
        raw_fd_ostream fetchFD(fName, err, LLVM_F_NONE);
        fetch->print(fetchFD);
        fetchFD.flush();
#endif

        verifyFunction(*fetch);

        mShG->mSetupPasses->run(*fetch);

#if defined(KNOB_SWRC_TRACING)
        sprintf(fName, "%s.se.ll", funcName);
        raw_fd_ostream seFetchFD(fName, err, LLVM_F_NONE);
        fetch->print(seFetchFD);
        seFetchFD.flush();
#endif

        mShG->mScalarPasses->run(*fetch);
        mShG->mScalarPasses->run(*fetch);

#if defined(KNOB_SWRC_TRACING)
        sprintf(fName, "%s.opt.ll", funcName);
        raw_fd_ostream optFetchFD(fName, err, LLVM_F_NONE);
        fetch->print(optFetchFD);
        optFetchFD.flush();
#endif

        mShG->mpExec->finalizeObject();
        void *pfnFetch = mShG->mpExec->getPointerToFunction(fetch);

#if defined(KNOB_SWRC_TRACING)
        sprintf(fName, "%s.bin", funcName);
        FILE *fd = fopen(fName, "wb");
        fwrite(pfnFetch, 1, 2048, fd);
        fclose(fd);
#endif

        return (PFN_FETCH_FUNC)pfnFetch;
    }

    Value *GetIndex(UINT index, Value *indices)
    {
        if (mContiguity == SWRC_DISCONTIGUOUS_IB)
        {
            Value *indexP = mShG->mBuilder.CreateGEP(indices, ConstantInt::get(mShG->mInt32Ty, index));
            indexP = mShG->mBuilder.CreateLoad(indexP);

            return mShG->mBuilder.CreateZExt(indexP, mShG->mInt64Ty);
        }
        else if (mContiguity == SWRC_CONTIGUOUS_IB)
        {
            Value *indexP = mShG->mBuilder.CreateGEP(indices, ConstantInt::get(mShG->mInt32Ty, 0));
            Value *idx = mShG->mBuilder.CreateLoad(indexP);
            idx = mShG->mBuilder.CreateAdd(idx, ConstantInt::get(mShG->mInt32Ty, index));
            return mShG->mBuilder.CreateZExt(idx, mShG->mInt64Ty);
        }
        assert(false && "Unknown IB kind.");
        return 0;
    }

    ShG *mShG;
    HANDLE mhContext;
    UINT mNumElements;
    INPUT_ELEMENT_DESC (&mIEDs)[KNOB_NUM_ATTRIBUTES];
    UINT (&mVBStrides)[KNOB_NUM_STREAMS];
    SWRC_WORDCODE mContiguity;
    SWR_TYPE mIndexType;
};

struct OpInfo
{
    SWRC_WORDCODE mName;
    const char *mpName;
    UINT mNumArgs;
};

static const OpInfo gOpInfo[] =
    {
#undef ENTRY
#define ENTRY(NAME, ARGS, ...)   \
    {                            \
        SWRC_##NAME, #NAME, ARGS \
    }                            \
    ,
#include "swrcwordcode.inl"
#undef ENTRY
    };

std::map<SWRC_WORDCODE, const OpInfo *> MakeNameMap()
{
    std::map<SWRC_WORDCODE, const OpInfo *> map;
    for (UINT i = 0, N = sizeof(gOpInfo) / sizeof(gOpInfo[0]); i < N; ++i)
    {
        map[gOpInfo[i].mName] = &gOpInfo[i];
    }
    return map;
}
std::map<const char *, const OpInfo *> MakePNameMap()
{
    std::map<const char *, const OpInfo *> map;
    for (UINT i = 0, N = sizeof(gOpInfo) / sizeof(gOpInfo[0]); i < N; ++i)
    {
        map[gOpInfo[i].mpName] = &gOpInfo[i];
    }
    return map;
}
static const std::map<SWRC_WORDCODE, const OpInfo *> gNameMap = MakeNameMap();
static const std::map<const char *, const OpInfo *> gPNameMap = MakePNameMap();

struct SWRC_ASM
{
    struct DECL
    {
        UINT slot;
        SWRC_WORDCODE type;
        UINT subSet;
        Value *attr[4];
        Value *stepX[4];
        Value *stepY[4];
    };

    SWRC_ASM(ShG *pShG, SWR_SHADER_TYPE sType)
        : mShG(pShG), mShaderType(sType)
    {
        Initialize();
    }

    void Initialize()
    {
#if defined(KNOB_SWRC_TRACING)
        mpLogFile = stdout;
#endif

        mFreshVarName = (SWRC_WORDCODE)255;
        mCompactOutputs = false;
        mDoPerspective = false;
        mHorizontal = true;

        mFunction = Function::Create(mShG->mpfnTy, GlobalValue::ExternalLinkage,
                                     std::string(mShaderType == SHADER_VERTEX ? "VS" : "PS") + std::to_string((long long)(mShG->mFuncCount++)), mShG->mModule);

        mProlog = BasicBlock::Create(mShG->mContext, "Prolog", mFunction);
        mEpilog = BasicBlock::Create(mShG->mContext, "Epilog", mFunction);

        auto &args = mFunction->getArgumentList();
        mPIn = args.begin();
        mPOut = ++args.begin();

        mPIn->setName("in");
        mPOut->setName("out");

        mShG->mBuilder.SetInsertPoint(mProlog);
        std::vector<Value *> offset;
        offset.push_back(ConstantInt::get(mShG->mInt32Ty, 0));
        offset.push_back(ConstantInt::get(mShG->mInt32Ty, 1));
        mPConstAddr = mShG->mBuilder.CreateGEP(mPIn, offset);
        mPConstAddr->setName("ConstAddr");
        mPConstOpaque = mShG->mBuilder.CreateLoad(mPConstAddr);
        mPConstOpaque->setName("ConstOpaque");
        mPConst = mShG->mBuilder.CreateBitCast(mPConstOpaque, PointerType::get(mShG->mBuilder.getInt8Ty(), 0));
        mPConst->setName("Const");

        mShG->mBuilder.ClearInsertionPoint();

        mEntry = 0;
        mCurrent = 0;

        mSimtizeGEPBC = MDNode::get(mShG->mContext, std::vector<Value *>(1, mShG->mSimtize));
        mSimtizeLoad = MDNode::get(mShG->mContext, std::vector<Value *>(1, mShG->mSimtize));
#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "%s\n", "STARTSHADER");
#endif
    }

    void SetOption(SWRC_WORDCODE option, UINT a = 0, UINT b = 0)
    {
#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "SETOPTION %d\n", option);
#endif
        switch (option)
        {
        case SWRC_BROADCAST_CONSTANTS:
            mSimtizeGEPBC = MDNode::get(mShG->mContext, std::vector<Value *>(1, mShG->mSimtizeDont));
            mSimtizeLoad = MDNode::get(mShG->mContext, std::vector<Value *>(1, mShG->mSimtizeBroadcast));
            break;
        case SWRC_COMPACT_OUTPUTS:
            mCompactOutputs = true;
            break;
        case SWRC_DO_PERSPECTIVE:
            mDoPerspective = true;
            break;
        case SWRC_PS_HORIZONTAL:
            mHorizontal = true;
            break;
        case SWRC_PS_SCALAR:
            mHorizontal = false;
            break;
        case SWRC_TILE_ITERATIONS:
            mXIterations = a;
            mYIterations = b;
            break;
        default:
            break;
        }
    }

    SWRC_WORDCODE GetFreshVar()
    {
        mFreshVarName = (SWRC_WORDCODE)(((UINT)mFreshVarName) + 1);
        return mFreshVarName;
    }

    HANDLE Assemble()
    {
        return Assemble(0, 0);
    }

    HANDLE Assemble(UINT numOutSlots, const UINT *outSlots)
    {
#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "%s\n\n", "ENDSHADER");
#endif

        // Terminate the prolog.
        mShG->mBuilder.SetInsertPoint(mProlog);
        mShG->mBuilder.CreateBr(mEntry);

        // Terminate the epilog.
        mShG->mBuilder.SetInsertPoint(mEpilog);

        UINT slot = 0;
        std::set<UINT> outSlotsSet;
        if (numOutSlots > 0)
        {
            outSlotsSet.insert(&outSlots[0], &outSlots[0] + numOutSlots);
        }
        for (auto itr = mOutputSlotMap.begin(), ind = mOutputSlotMap.end(); itr != ind; ++itr, ++slot)
        {
            if ((outSlots != 0) && (outSlotsSet.find(itr->first) == outSlotsSet.end()))
                continue;
            std::vector<Value *> offset;
            offset.push_back(ConstantInt::get(mShG->mInt32Ty, 0));
            offset.push_back(ConstantInt::get(mShG->mInt32Ty, 0));
            offset.push_back(ConstantInt::get(mShG->mInt32Ty, mCompactOutputs ? slot : itr->first));
            Value *pAttr = mShG->mBuilder.CreateGEP(mPOut, offset);

            Value *attr = mShG->mBuilder.CreateLoad(itr->second);
            mShG->mBuilder.CreateStore(attr, pAttr);
        }

        mShG->mBuilder.CreateRetVoid();

#if defined(KNOB_SWRC_TRACING)
        std::string error;
        const char *funcName = mFunction->getName().data();
        char fName[1024];
        sprintf(fName, "%s.scalar.ll", funcName);
        raw_fd_ostream scalar(fName, error, LLVM_F_NONE);
        sprintf(fName, "%s.scalar.opt.ll", funcName);
        raw_fd_ostream scalaropt(fName, error, LLVM_F_NONE);
        sprintf(fName, "%s.vector.ll", funcName);
        raw_fd_ostream vector(fName, error, LLVM_F_NONE);
        sprintf(fName, "%s.vector.opt.ll", funcName);
        raw_fd_ostream vectoropt(fName, error, LLVM_F_NONE);
        mFunction->print(scalar);
        scalar.flush();
#endif

        verifyFunction(*mFunction);

        mShG->mSetupPasses->run(*mFunction);
        mShG->mScalarPasses->run(*mFunction);
        mShG->mScalarPasses->run(*mFunction);

#if defined(KNOB_SWRC_TRACING)
        mFunction->print(scalaropt);
        scalaropt.flush();
#endif

        PropogateBroadcastMD();

        Function *pNewFunc = llvm::CreateSimtizedFunction(mFunction, mShG->mVWidth, mShG->mSimtFunctionMap);
        mFunction->eraseFromParent();
        mFunction = pNewFunc;

#if defined(KNOB_SWRC_TRACING)
        mFunction->print(vector);
        vector.flush();
#endif

        switch (mShaderType)
        {
        case SHADER_VERTEX:
            CaptureVertexShader();
            break;
        case SHADER_PIXEL:
            CapturePixelShader();
            break;
        default:
            assert(0 && "Invalid shader type.");
        }

        mShG->mVectorPasses->run(*mFunction);
        mShG->mVectorPasses->run(*mFunction);

#if defined(KNOB_SWRC_TRACING)
        mFunction->print(vectoropt);
        vectoropt.flush();
#endif

        mShG->mpExec->finalizeObject();
        void *pfn = mShG->mpExec->getPointerToFunction(mFunction);

#if defined(KNOB_SWRC_TRACING)
        sprintf(fName, "%s.bin", funcName);
        FILE *fd = fopen(fName, "wb");
        fwrite(pfn, 1, 2048, fd);
        fclose(fd);
#endif

        return (HANDLE)pfn;
    }

    void PropogateBroadcastMD() // MD = Metadata
    {
        // Propogate BC MD through GEPs, BCs, and up to LOAD-to-values.
        std::vector<Value *> workList;
        workList.push_back(mPConstAddr);

        while (!workList.empty())
        {
            Value *top = workList.back();
            workList.pop_back();

            if (!isa<GetElementPtrInst>(top) &&
                !isa<BitCastInst>(top) &&
                !isa<LoadInst>(top))
            {
                continue;
            }

            Instruction *bc = cast<Instruction>(top);
            if (isa<GetElementPtrInst>(bc) ||
                isa<BitCastInst>(bc) ||
                bc->getType()->isPointerTy())
            {
                bc->setMetadata(mShG->mBroadcastMDName, mSimtizeGEPBC);
            }
            else
            {
                bc->setMetadata(mShG->mBroadcastMDName, mSimtizeLoad);
            }

#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR >= 5)
            for (User *U : bc->users())
            {
                workList.push_back(U);
            }
#else
            for (auto BB = bc->use_begin(), BE = bc->use_end(); BB != BE; ++BB)
            {
                workList.push_back(*BB);
            }
#endif
        }
    }

    void CaptureVertexShader()
    {
        // Nothing to do.
    }

    void CapturePixelShader()
    {
        // XXX: the PS kernel uses the VERTEX*PUT. That means we need to adapt
        // the outer PS to the inner kernel.
        // The outer PS has the following form:
        // SWR_TRIANGLE_DESC* -> SWR_PIXELOUTPUT*

        // Some values.
        Constant *zero = ConstantInt::get(mShG->mInt32Ty, 0);
        Constant *vzero = ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, zero));
        Constant *twof = ConstantFP::get(mShG->mFP32Ty, 2.0);
        Constant *vtwof = ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, twof));

        // Some types.
        Type *simtInt32Ty = vzero->getType();
        Type *simtFP32Ty = vtwof->getType();

        // Adapted from "shader_math.h" GenericPixelShader.

        auto *pPSFunc = Function::Create(mShG->mPSShaderTy, GlobalValue::ExternalLinkage, "PS.outer", mShG->mModule);

        auto *body = BasicBlock::Create(mShG->mContext, "body", pPSFunc);

        mShG->mBuilder.SetInsertPoint(body);

        // Create a dummy in & out.
        auto *kernelInTy = SimtizeType(&mShG->mContext, mShG->mVWidth, mShG->mVsInputTy);
        auto *kernelOutTy = SimtizeType(&mShG->mContext, mShG->mVWidth, mShG->mVsOutputTy);
        auto *pvIn = mShG->mBuilder.CreateAlloca(kernelInTy, 0);
        pvIn->setName("kernel.in");
        auto *pvOut = mShG->mBuilder.CreateAlloca(kernelOutTy, 0);
        pvOut->setName("kernel.out");

        // Get arguments.
        auto &args = pPSFunc->getArgumentList();
        Value *pIn = args.begin();
        pIn->setName("ps.in");
        Value *pOut = ++args.begin();
        pOut->setName("ps.out");

        // Get coverage mask.
        std::vector<Value *> offset;
        offset.push_back(zero);
        offset.push_back(ConstantInt::get(mShG->mInt32Ty, 11)); // "11" means coverage mask!

        auto *coverageMask = mShG->mBuilder.CreateGEP(pIn, offset);
        coverageMask = mShG->mBuilder.CreateLoad(coverageMask);
        coverageMask->setName("coverageMask");

        offset[1] = ConstantInt::get(mShG->mInt32Ty, 8); // "8" means "tileX"
        auto *tileX = mShG->mBuilder.CreateGEP(pIn, offset);
        tileX = mShG->mBuilder.CreateLoad(tileX);
        tileX->setName("tile.X");

        offset[1] = ConstantInt::get(mShG->mInt32Ty, 9); // "9" means "tileY"
        auto *tileY = mShG->mBuilder.CreateGEP(pIn, offset);
        tileY = mShG->mBuilder.CreateLoad(tileY);
        tileY->setName("tile.Y");

        Value *vX = 0;
        Value *vY = 0;

        if (mHorizontal)
        {
            auto *x = mShG->mBuilder.CreateMul(tileX, ConstantInt::get(mShG->mInt32Ty, mXIterations));
            auto *y = mShG->mBuilder.CreateMul(tileY, ConstantInt::get(mShG->mInt32Ty, mYIterations));

            x = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtInt32Ty), x, zero);
            vX = mShG->mBuilder.CreateShuffleVector(x, x, vzero);

            y = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtInt32Ty), y, zero);
            vY = mShG->mBuilder.CreateShuffleVector(y, y, vzero);
        }
        else
        {
            vX = tileX;
            vY = tileY;
        }
        auto *vXf = mShG->mBuilder.CreateSIToFP(vX, simtFP32Ty);
        auto *vYf = mShG->mBuilder.CreateSIToFP(vY, simtFP32Ty);
        vXf->setName("tile.X scale");
        vYf->setName("tile.Y scale");

        // Compute I, J, and 1/W, etc.
        auto IJKoffset = offset;
        IJKoffset.push_back(ConstantInt::get(mShG->mInt32Ty, 0));
        Value *vIJs[2][3] = {};

        auto *undefVec = UndefValue::get(simtFP32Ty);
        for (int i = 0; i < 2; ++i)
        {
            // i == 'I', 'J'
            IJKoffset[1] = ConstantInt::get(mShG->mInt32Ty, i);
            for (int j = 0; j < 3; ++j)
            {
                // j == 'a', 'b', 'c'
                IJKoffset[1] = ConstantInt::get(mShG->mInt32Ty, j);
                vIJs[i][j] = mShG->mBuilder.CreateGEP(pIn, IJKoffset);
                vIJs[i][j] = mShG->mBuilder.CreateLoad(vIJs[i][j]);
                if (mHorizontal)
                {
                    assert((vIJs[i][j]->getType() == mShG->mFP32Ty) && "Must be FP32.");
                    vIJs[i][j] = mShG->mBuilder.CreateInsertElement(undefVec, vIJs[i][j], zero);
                    vIJs[i][j] = mShG->mBuilder.CreateShuffleVector(vIJs[i][j], vIJs[i][j], vzero);
                    vIJs[i][j]->setName("raw IJs");
                }
            }
        }

        Value *vIJ[2] = { 0 };

        // Do plane equation (top half).
        // XXX: convert to FMAD.
        for (int i = 0; i < 2; ++i)
        {
            auto *vOut = mShG->mBuilder.CreateFMul(vIJs[i][0], vXf);
            auto *vOut2 = mShG->mBuilder.CreateFMul(vIJs[i][1], vYf);
            vOut = mShG->mBuilder.CreateFAdd(vOut, vOut2);
            vIJ[i] = mShG->mBuilder.CreateFAdd(vOut, vIJs[i][2]);
            vIJ[i]->setName("IJ planed");
        }

        // Load, broadcast 1/Det
        offset[1] = ConstantInt::get(mShG->mInt32Ty, 6); // 'recipDet' offset
        auto *vRecipDet = mShG->mBuilder.CreateGEP(pIn, offset);
        vRecipDet = mShG->mBuilder.CreateLoad(vRecipDet);
        if (mHorizontal)
        {
            vRecipDet = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtFP32Ty), vRecipDet, zero);
            vRecipDet = mShG->mBuilder.CreateShuffleVector(vRecipDet, vRecipDet, vzero);
        }
        vRecipDet->setName("vRecipDet");

        // Multiply by 1/det.
        for (int i = 0; i < 2; ++i)
        {
            vIJ[i] = mShG->mBuilder.CreateFMul(vIJ[i], vRecipDet);
            vIJ[i]->setName("persp correct vIJ");
        }

        // Load, broadcast, and compute vZ
        IJKoffset[1] = ConstantInt::get(mShG->mInt32Ty, 2); // 'Z' magic offset
        Value *vZs[3] = { 0 };
        for (int i = 0; i < 3; ++i)
        {
            IJKoffset[2] = ConstantInt::get(mShG->mInt32Ty, i);
            vZs[i] = mShG->mBuilder.CreateGEP(pIn, IJKoffset);
            vZs[i] = mShG->mBuilder.CreateLoad(vZs[i]);
            if (mHorizontal)
            {
                vZs[i] = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtFP32Ty), vZs[i], zero);
                vZs[i] = mShG->mBuilder.CreateShuffleVector(vZs[i], vZs[i], vzero);
            }
            vZs[i]->setName("raw vZs");
        }

        auto *vOut = mShG->mBuilder.CreateFMul(vZs[0], vXf);
        auto *vOut2 = mShG->mBuilder.CreateFMul(vZs[1], vYf);
        vOut = mShG->mBuilder.CreateFAdd(vOut, vOut2);
        auto *vZ = mShG->mBuilder.CreateFAdd(vOut, vZs[2]);
        vZ->setName("vZ");

        Value *vZStep[2] = { 0 };

        // Load, broadcast Z-step
        for (int i = 0; i < 2; ++i)
        {
            offset[1] = ConstantInt::get(mShG->mInt32Ty, 4 + i); // 'vZStep' is 4 & 5 offset
            vZStep[i] = mShG->mBuilder.CreateGEP(pIn, offset);
            vZStep[i] = mShG->mBuilder.CreateLoad(vZStep[i]);
            if (mHorizontal)
            {
                vZStep[i] = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtFP32Ty), vZStep[i], zero);
                vZStep[i] = mShG->mBuilder.CreateShuffleVector(vZStep[i], vZStep[i], vzero);
            }
            vZStep[i]->setName("z*Step");
        }

        // i and j step functions
        auto *vTwoOverDet = mShG->mBuilder.CreateFMul(vRecipDet, vtwof);
        Value *vSteps[2][2] = {}; // { I, J } * { X, Y }
        for (int i = 0; i < 2; ++i)
        {
            for (int x = 0; x < 2; ++x)
            {
                vSteps[i][x] = mShG->mBuilder.CreateFMul(vIJs[i][x], vTwoOverDet);
                vSteps[i][x]->setName("X|Y steps");
            }
        }

        // Perspective steps.
        Value *v1OverW = 0;
        Value *v1OverWSteps[2] = { 0 };
        if (mDoPerspective)
        {
            IJKoffset[1] = ConstantInt::get(mShG->mInt32Ty, 3); // 'OneOverW' is 3

            Value *v1OverWs[3] = { 0 };
            for (int i = 0; i < 3; ++i)
            {
                IJKoffset[i] = ConstantInt::get(mShG->mInt32Ty, i); // A, B, C
                v1OverWs[i] = mShG->mBuilder.CreateGEP(pIn, IJKoffset);
                v1OverWs[i] = mShG->mBuilder.CreateLoad(v1OverWs[i]);
                if (mHorizontal)
                {
                    v1OverWs[i] = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtFP32Ty), v1OverWs[i], zero);
                    v1OverWs[i] = mShG->mBuilder.CreateShuffleVector(v1OverWs[i], v1OverWs[i], vzero);
                }
            }

            // XXX: implement as FMAD.
            auto *vOut = mShG->mBuilder.CreateFMul(v1OverWs[0], vXf);
            auto *vOut2 = mShG->mBuilder.CreateFMul(v1OverWs[1], vYf);
            vOut = mShG->mBuilder.CreateFAdd(vOut, vOut2);
            v1OverW = mShG->mBuilder.CreateFAdd(vOut, v1OverWs[2]);
            v1OverW->setName("1.0/W");

            for (int i = 0; i < 2; ++i)
            {
                // XXX: implement as FMAD.
                auto *tmp0 = mShG->mBuilder.CreateFMul(v1OverWs[0], vSteps[i][0]);
                auto *tmp1 = mShG->mBuilder.CreateFMul(v1OverWs[1], vSteps[i][1]);
                v1OverWSteps[i] = mShG->mBuilder.CreateFAdd(tmp0, tmp1);
                v1OverWSteps[i]->setName("1.0f/W Steps");
            }
        }

        // Per-attribute information.
        offset[0] = zero;
        offset[1] = ConstantInt::get(mShG->mInt32Ty, 7); // 'pInterpBuffer' offset

        // Input slots are packed and in the order that the DCLs are declared
        // during assembly.
        if (mHorizontal)
        {
            for (std::size_t i = 0, N = mInputSlots.size(), off = 0; i < N; ++i)
            {
                auto &dcl = mInputSlots[i];
                Value *vABC[3] = { 0 };
                for (UINT j = 0; j < 3; ++j, ++off)
                {
                    IJKoffset[2] = ConstantInt::get(mShG->mInt32Ty, off * mShG->mVWidth * sizeof(float));
                    auto *attr = mShG->mBuilder.CreateGEP(pIn, offset);
                    attr = mShG->mBuilder.CreateBitCast(attr, PointerType::get(simtFP32Ty, 0));
                    attr = mShG->mBuilder.CreateAlignedLoad(attr, 1);
                    //attr            = mShG->mBuilder.CreateLoad(attr);
                    //if (mHorizontal)
                    //{
                    //    attr        = mShG->mBuilder.CreateInsertElement(UndefValue::get(simtFP32Ty), attr, zero);
                    //    attr        = mShG->mBuilder.CreateShuffleVector(attr, attr, vzero);
                    //}
                    vABC[j] = attr;
                    vABC[j]->setName("ABC values");
                }
                for (UINT s = 0; s < dcl.subSet; ++s)
                {

                    auto *vA = mShG->mBuilder.CreateShuffleVector(vABC[0], vABC[0], ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantInt::get(mShG->mInt32Ty, s))));
                    auto *vB = mShG->mBuilder.CreateShuffleVector(vABC[1], vABC[1], ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantInt::get(mShG->mInt32Ty, s))));
                    auto *vC = mShG->mBuilder.CreateShuffleVector(vABC[2], vABC[2], ConstantVector::get(std::vector<Constant *>(mShG->mVWidth, ConstantInt::get(mShG->mInt32Ty, s))));

                    auto *vOut = mShG->mBuilder.CreateFMul(vIJ[0], vA);
                    auto *vOut2 = mShG->mBuilder.CreateFMul(vIJ[1], vB);
                    vOut = mShG->mBuilder.CreateFAdd(vOut, vOut2);
                    dcl.attr[s] = mShG->mBuilder.CreateFAdd(vOut, vC);

                    vOut = mShG->mBuilder.CreateFMul(vA, vSteps[0][0]);
                    vOut2 = mShG->mBuilder.CreateFMul(vB, vSteps[1][0]);
                    dcl.stepX[s] = mShG->mBuilder.CreateFAdd(vOut, vOut2);

                    vOut = mShG->mBuilder.CreateFMul(vA, vSteps[0][1]);
                    vOut2 = mShG->mBuilder.CreateFMul(vB, vSteps[1][1]);
                    dcl.stepY[s] = mShG->mBuilder.CreateFAdd(vOut, vOut2);
                }
            }
        }
        else
        {
        }

        // Get RTs.
        // * RTs are assumed to have the 'sparse' layout as described in the kernel.
        // * The 'type' of the RTs is one of:
        //      - ZFUNC_xxx
        //      - V4FP32, UNORM8, ..., aka, 'typed'
        // * Each ZFUNC_xxx RT is tested with a zfunc.
        //      - If any ZFUNC_xxx RT lanes fails, the whole lane is discarded.
        // * Each "typed" RT must have downconversion post kernel run.

        std::vector<Value *> dclSlot(4, zero);
        std::vector<Value *> colSlot(1, zero);
        for (UINT y = 0; y < mYIterations; ++y)
        {
            auto *vStart1OverW = v1OverW;
            for (UINT x = 0; x < mXIterations; ++x)
            {
                // XXX: write the dcls into the proper slot.
                for (std::size_t i = 0, N = mInputSlots.size(); i < N; ++i)
                {
                    auto &dcl = mInputSlots[i];
                    dclSlot[2] = ConstantInt::get(mShG->mInt32Ty, dcl.slot);
                    for (UINT s = 0; s < dcl.subSet; ++s)
                    {
                        // XXX: see note.
                        // Write this into "dcl.slot * 4 + s" logical slot;
                        // where we divide the slot into "coalesce count" subslots,
                        // writing into the 'coalesce index' subslot.
                        //
                        // XXX: for LLVM, the type of the kernel.in is:
                        //      { [6 x { <mVWidth x float>, ... }, ... }*
                        // So the GEP is: 0, 0, dcl.slot, s
                        // Then we bitcast to the 'coalescing' type
                        dclSlot[3] = ConstantInt::get(mShG->mInt32Ty, s);
                        auto *slot = mShG->mBuilder.CreateGEP(pvIn, dclSlot);
                        mShG->mBuilder.CreateStore(dcl.attr[s], slot);
                    }
                }

                // Issue a call to the kernel.
                mShG->mBuilder.CreateCall2(mFunction, pvIn, pvOut);

                for (std::size_t i = 0, N = mInputSlots.size(); i < N; ++i)
                {
                    // Rasterize the attributes.
                    auto &dcl = mInputSlots[i];
                    for (UINT s = 0; s < dcl.subSet; ++s)
                    {

                        // Ox-plow iteration of the tile.
                        // +x +x +x ... +y
                        // -x -x -x ... +y
                        // +x +x +x ... +y
                        // ...
                        // +x +x +x ... +y
                        if (x == (mXIterations - 1))
                        {
                            dcl.attr[s] = mShG->mBuilder.CreateFAdd(dcl.attr[s], dcl.stepY[s]);
                        }
                        else
                        {
                            if ((y % 2) == 0)
                            {
                                dcl.attr[s] = mShG->mBuilder.CreateFAdd(dcl.attr[s], dcl.stepX[s]);
                            }
                            else
                            {
                                dcl.attr[s] = mShG->mBuilder.CreateFSub(dcl.attr[s], dcl.stepX[s]);
                            }
                        }
                    }
                }
            }

            v1OverW = mShG->mBuilder.CreateFAdd(vStart1OverW, v1OverWSteps[1]);
        }

        mShG->mBuilder.CreateRetVoid();

#if defined(KNOB_SWRC_TRACING)
        std::string error;
        char fName[1024];
        sprintf(fName, "%s.capture.ll", mFunction->getName().data());
        raw_fd_ostream capture(fName, error, LLVM_F_NONE);
        pPSFunc->print(capture);
        capture.flush();
#endif

        // The idea is to 'capture' the inner function 'mFunction' and, instead,
        // return this newly created function. This relies *critically* on the alwaysinline
        // pass to *guarantee* the inlining of the inner kernel.
        // mFunction = pPSFunc;
    }

    SWRC_WORDCODE AddBlock()
    {
        SWRC_WORDCODE block = GetFreshVar();
        mBlockMap[block] = BasicBlock::Create(mShG->mContext, "USER", mFunction);
        return block;
    }

    void SetEntryBlock(SWRC_WORDCODE block)
    {
#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "; %s\n", mFunction->getName().data());
        fprintf(mpLogFile, "EntryBlock(%d)\n", block);
#endif
        mEntry = mBlockMap[block];
    }

    void SetCurrentBlock(SWRC_WORDCODE block)
    {
#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "BLOCK (%d)\n", block);
#endif
        mCurrent = mBlockMap[block];
        mShG->mBuilder.SetInsertPoint(mCurrent);
    }

    void ResetCurrentBlock()
    {
        if (mCurrent)
        {
            mShG->mBuilder.SetInsertPoint(mCurrent);
        }
        else
        {
            mShG->mBuilder.ClearInsertionPoint();
        }
    }

    SWRC_WORDCODE AddDecl(UINT slot, SWRC_WORDCODE inOrOut, SWRC_WORDCODE type, UINT subSet)
    {
#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "	%s ", "DECL");
#endif
        DECL dcl = { slot, type, subSet };

        assert(((mShaderType != SHADER_VERTEX) || (type == SWRC_V4FP32)) && "VS only supports V4F32 output types.");
        assert(((mShaderType != SHADER_VERTEX) || (subSet == 4)) && "VS does not support partial attributes.");

        if (inOrOut == SWRC_IN)
        {
            mInputSlots.push_back(dcl);
            mShG->mBuilder.SetInsertPoint(mProlog);
            SWRC_WORDCODE name = GetFreshVar();
            std::vector<Value *> offset;
            offset.push_back(ConstantInt::get(mShG->mInt32Ty, 0));
            offset.push_back(ConstantInt::get(mShG->mInt32Ty, 0));
            offset.push_back(ConstantInt::get(mShG->mInt32Ty, slot));
            Value *pAttr = mShG->mBuilder.CreateGEP(mPIn, offset);
            Value *attr = mShG->mBuilder.CreateLoad(pAttr);
            Value *cell = mShG->mBuilder.CreateAlloca(attr->getType());
            mShG->mBuilder.CreateStore(attr, cell);
            mRegMap[name] = cell;

            ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
            fprintf(mpLogFile, "INPUT  r%-4d %d {%d}\n", name, slot, subSet);
#endif

            return name;
        }
        else if (inOrOut == SWRC_OUT)
        {
            mOutputSlots.push_back(dcl);
            mShG->mBuilder.SetInsertPoint(mProlog);
            SWRC_WORDCODE name = GetFreshVar();
            Value *cell = mShG->mBuilder.CreateAlloca(mShG->mV4FP32Ty);
            mRegMap[name] = cell;

            mOutputSlotMap[slot] = cell;

            ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
            const char *pTypes[] = { "UNORM8", "INT32", "FP32", "V4INT32", "V4FP32", "V4UNORM8" };
            fprintf(mpLogFile, "OUTPUT r%-4d %d as %s\n", name, slot, pTypes[type - SWRC_UNORM8]);
#endif

            return name;
        }

        return SWRC_NOT_A_TOKEN;
    }

    SWRC_WORDCODE AddConstant(UINT byteOffset, SWRC_WORDCODE type)
    {
        mShG->mBuilder.SetInsertPoint(mProlog);

        GetElementPtrInst *gep = cast<GetElementPtrInst>(mShG->mBuilder.CreateGEP(mPConst, std::vector<Value *>(1, ConstantInt::get(mShG->mInt32Ty, byteOffset))));
        Instruction *bitc = 0;
        switch (type)
        {
        case SWRC_FP32:
            bitc = cast<Instruction>(mShG->mBuilder.CreateBitCast(gep, PointerType::get(mShG->mFP32Ty, 0)));
            break;
        case SWRC_INT32:
            bitc = cast<Instruction>(mShG->mBuilder.CreateBitCast(gep, PointerType::get(mShG->mInt32Ty, 0)));
            break;
        case SWRC_V4FP32:
            bitc = cast<Instruction>(mShG->mBuilder.CreateBitCast(gep, PointerType::get(mShG->mV4FP32Ty, 0)));
            break;
        case SWRC_V4INT32:
            bitc = cast<Instruction>(mShG->mBuilder.CreateBitCast(gep, PointerType::get(mShG->mV4Int32Ty, 0)));
            break;
        default:
            assert(0 && "Unsupported constant type");
        }
        LoadInst *load = mShG->mBuilder.CreateAlignedLoad(bitc, 1, false);
        Value *cell = mShG->mBuilder.CreateAlloca(load->getType());
        SWRC_WORDCODE name = GetFreshVar();
        mRegMap[name] = cell;
        mShG->mBuilder.CreateStore(load, cell);

        ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
        static const char *TYPENAME[] = { "FP32", "INT32", "V4FP32", "V4INT32" };
        const char *pTyName = 0;
        switch (type)
        {
        case SWRC_FP32:
            pTyName = TYPENAME[0];
            break;
        case SWRC_INT32:
            pTyName = TYPENAME[1];
            break;
        case SWRC_V4FP32:
            pTyName = TYPENAME[2];
            break;
        case SWRC_V4INT32:
            pTyName = TYPENAME[3];
            break;
        }
        fprintf(mpLogFile, "	CONSTANT r%-4d := *0x%08x %s\n", name, byteOffset, pTyName);
#endif

        return name;
    }

    SWRC_WORDCODE AddImm(float f)
    {
        mShG->mBuilder.SetInsertPoint(mProlog);

        SWRC_WORDCODE name = GetFreshVar();
        Value *cell = mShG->mBuilder.CreateAlloca(mShG->mFP32Ty);
        mShG->mBuilder.CreateStore(ConstantFP::get(mShG->mFP32Ty, f), cell);
        mRegMap[name] = cell;

        ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "	IMM r%-4d %f\n", name, f);
#endif

        return name;
    }

    SWRC_WORDCODE AddImm(float f0, float f1, float f2, float f3)
    {
        mShG->mBuilder.SetInsertPoint(mProlog);

        SWRC_WORDCODE name = GetFreshVar();
        Value *cell = mShG->mBuilder.CreateAlloca(mShG->mV4FP32Ty);
        std::vector<Constant *> C4(4);
        C4[0] = ConstantFP::get(mShG->mFP32Ty, f0);
        C4[1] = ConstantFP::get(mShG->mFP32Ty, f1);
        C4[2] = ConstantFP::get(mShG->mFP32Ty, f2);
        C4[3] = ConstantFP::get(mShG->mFP32Ty, f3);
        Constant *C = ConstantStruct::get(mShG->mV4FP32Ty, C4);
        mShG->mBuilder.CreateStore(C, cell);
        mRegMap[name] = cell;

        ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "	IMM r%-4d %f %f %f %f\n", name, f0, f1, f2, f3);
#endif

        return name;
    }

    SWRC_WORDCODE AddImm(UINT i)
    {
        mShG->mBuilder.SetInsertPoint(mProlog);

        SWRC_WORDCODE name = GetFreshVar();
        Value *cell = mShG->mBuilder.CreateAlloca(mShG->mInt32Ty);
        mShG->mBuilder.CreateStore(ConstantInt::get(mShG->mInt32Ty, i), cell);
        mRegMap[name] = cell;

        ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "	IMM r%-4d %d\n", name, i);
#endif

        return name;
    }

    SWRC_WORDCODE AddImm(UINT i0, UINT i1, UINT i2, UINT i3)
    {
        mShG->mBuilder.SetInsertPoint(mProlog);

        SWRC_WORDCODE name = GetFreshVar();
        Value *cell = mShG->mBuilder.CreateAlloca(mShG->mV4Int32Ty);
        std::vector<Constant *> C4(4);
        C4[0] = ConstantFP::get(mShG->mInt32Ty, i0);
        C4[1] = ConstantFP::get(mShG->mInt32Ty, i1);
        C4[2] = ConstantFP::get(mShG->mInt32Ty, i2);
        C4[3] = ConstantFP::get(mShG->mInt32Ty, i3);
        Constant *C = ConstantStruct::get(mShG->mV4Int32Ty, C4);
        mShG->mBuilder.CreateStore(C, cell);
        mRegMap[name] = cell;

        ResetCurrentBlock();

#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "	IMM r%-4d %d %d %d %d\n", name, i0, i1, i2, i3);
#endif

        return name;
    }

    SWRC_WORDCODE AddInstruction(SWRC_WORDCODE op, std::vector<SWRC_WORDCODE> const &args)
    {

#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, "	%7s", gOpInfo[op].mpName);
#endif
        // Handle flow control, first.
        switch (op)
        {
        case SWRC_RET:
#if defined(KNOB_SWRC_TRACING)
            fprintf(mpLogFile, "%s", "\n");
#endif
            mShG->mBuilder.CreateBr(mEpilog);
            return SWRC_NOT_A_TOKEN;
        default:
            break;
        }

        OpInfo const &opInfo = gOpInfo[op];

        bool hasDest = (opInfo.mNumArgs + 1) == args.size();
        assert(hasDest || (opInfo.mNumArgs == args.size()));

        // Load the arguments.
        std::vector<Value *> vargs;
        for (std::size_t i = hasDest ? 1 : 0, j = 0, N = args.size(); i < N; ++i, ++j)
        {
            // A few operators need constant-injection.
            switch (op)
            {
            case SWRC_GETELT:
                if (j == 1)
                {
                    //			-----	0	1
                    //	GETELT	[dst]	src	idx
                    vargs.push_back(0);
                    continue;
                }
                break;
            case SWRC_SETELT:
                if (j == 1)
                {
                    //			-----	0	1	2
                    //	SETELT	[dst]	src	idx	src
                    vargs.push_back(0);
                    continue;
                }
                break;
            case SWRC_MOVCMP:
                if (j == 0)
                {
                    // MOVCMP cmpop cmpL cmpR srcT srcF
                    vargs.push_back(0);
                    continue;
                }
                break;
            default:
                break;
            }
            vargs.push_back(mShG->mBuilder.CreateLoad(mRegMap[args[i]]));
        }

        // Compute the operation.
        Value *result = 0;
        UINT numDPElts = 0;
        switch (op)
        {
        case SWRC_MOV:
            result = vargs[0];
            break;
        case SWRC_MOVCMP:
        {
            Value *fcmp = 0;
            switch ((SWRC_CMPOP)args[0])
            {
            case SWRC_CMP_EQ:
                fcmp = mShG->mPtWise.CreateFCmpOEQ(vargs[1], vargs[2]);
                break;
            case SWRC_CMP_NE:
                fcmp = mShG->mPtWise.CreateFCmpONE(vargs[1], vargs[2]);
                break;
            case SWRC_CMP_LT:
                fcmp = mShG->mPtWise.CreateFCmpOLT(vargs[1], vargs[2]);
                break;
            case SWRC_CMP_LE:
                fcmp = mShG->mPtWise.CreateFCmpOLE(vargs[1], vargs[2]);
                break;
            case SWRC_CMP_GT:
                fcmp = mShG->mPtWise.CreateFCmpOGT(vargs[1], vargs[2]);
                break;
            case SWRC_CMP_GE:
                fcmp = mShG->mPtWise.CreateFCmpOGE(vargs[1], vargs[2]);
                break;
            }
            result = mShG->mPtWise.CreateSelect(fcmp, vargs[3], vargs[4]);
        }
        break;
        case SWRC_MOVC:
        {
            Constant *zero = mShG->mPtWise.CreateMatchingConstant(ConstantFP::get(mShG->mBuilder.getFloatTy(), 0.0), vargs[0]->getType());
            Value *fcmp = mShG->mPtWise.CreateFCmpONE(vargs[0], zero);
            result = mShG->mPtWise.CreateSelect(fcmp, vargs[1], vargs[2]);
        }
        break;
        case SWRC_ADD:
            result = mShG->mPtWise.CreateAdd(vargs[0], vargs[1]);
            break;
        case SWRC_FADD:
            result = mShG->mPtWise.CreateFAdd(vargs[0], vargs[1]);
            break;
        case SWRC_SUB:
            result = mShG->mPtWise.CreateSub(vargs[0], vargs[1]);
            break;
        case SWRC_FSUB:
            result = mShG->mPtWise.CreateFSub(vargs[0], vargs[1]);
            break;
        case SWRC_MUL:
            result = mShG->mPtWise.CreateMul(vargs[0], vargs[1]);
            break;
        case SWRC_FMUL:
            result = mShG->mPtWise.CreateFMul(vargs[0], vargs[1]);
            break;
        case SWRC_DIV:
            result = mShG->mPtWise.CreateSDiv(vargs[0], vargs[1]);
            break;
        case SWRC_FDIV:
            result = mShG->mPtWise.CreateFDiv(vargs[0], vargs[1]);
            break;
        case SWRC_FRCPP:
            result = mShG->mPtWise.CreateCall(mShG->mRcp, vargs);
            break;
        case SWRC_FRCP:
        {
            // Cheapest way to get full precision FRCP is FDIV.
            auto one = ConstantFP::get(mShG->mFP32Ty, 1.0f);
            result = mShG->mPtWise.CreateFDiv(one, vargs[0]);
        }
        break;
        case SWRC_FSQRT:
            result = mShG->mPtWise.CreateCall(mShG->mSqrt, vargs);
            break;
        case SWRC_FRSQRTP:
            result = mShG->mPtWise.CreateCall(mShG->mRSqrt, vargs);
            break;
        case SWRC_FRSQRT:
        {
            // XXX: compare FSQRT against FDIV FSQRT sequence.
            // IN: x
            // r <- rsqrt x
            // 0.5 * r * (3 - (x * r) * r))
            // IDEALLY:
            //	r <- rsqrt x
            //	a <- fmul x r
            //	b <- fsubr a r 3
            //	c <- fmul 0.5 r
            //	OUT <- fmul c b
            auto x = vargs[0];
            auto r = mShG->mPtWise.CreateCall(mShG->mRSqrt, vargs);
            auto half = ConstantFP::get(mShG->mFP32Ty, 0.5);
            auto three = ConstantFP::get(mShG->mFP32Ty, 3.0f);
            auto half_r = mShG->mPtWise.CreateFMul(half, r);
            auto x_r = mShG->mPtWise.CreateFMul(x, r);
            auto x_r_r = mShG->mPtWise.CreateFMul(x_r, r);
            auto t_xrr = mShG->mPtWise.CreateFSub(three, x_r_r);
            result = mShG->mPtWise.CreateFMul(half_r, t_xrr);
        }
        break;
        case SWRC_FMULADD:
            result = mShG->mPtWise.CreateCall(mShG->mFMA, vargs);
            break;
        case SWRC_FMULSUB:
            assert(false && "PtWiseBuilder needs FNeg");
            break;
        case SWRC_MAX:
            result = mShG->mPtWise.CreateCall(mShG->mMax, vargs);
            break;
        case SWRC_FMAX:
            result = mShG->mPtWise.CreateCall(mShG->mFMax, vargs);
            break;
        case SWRC_MIN:
            result = mShG->mPtWise.CreateCall(mShG->mMin, vargs);
            break;
        case SWRC_FMIN:
            result = mShG->mPtWise.CreateCall(mShG->mFMin, vargs);
            break;
#if !defined(_WIN32)
        case SWRC_F4TR:
            result = mShG->mPtWise.CreateCall(mShG->mF4TrF32, vargs);
            break;
#endif
        case SWRC_FDOT4:
            numDPElts = 1;
        case SWRC_FDOT3:
            numDPElts += 3;
            {
                Value *lhs = mShG->mBuilder.CreateExtractValue(vargs[0], std::vector<UINT>(1, 0));
                Value *rhs = mShG->mBuilder.CreateExtractValue(vargs[1], std::vector<UINT>(1, 0));
                result = mShG->mBuilder.CreateFMul(lhs, rhs);
                for (UINT i = 1; i < numDPElts; ++i)
                {
                    lhs = mShG->mBuilder.CreateExtractValue(vargs[0], std::vector<UINT>(1, i));
                    rhs = mShG->mBuilder.CreateExtractValue(vargs[1], std::vector<UINT>(1, i));
                    result = mShG->mBuilder.CreateCall3(mShG->mFMA, lhs, rhs, result);
                }
            }
            break;
        case SWRC_MKVEC:
        {
            Type *aggType = 0;
            if (vargs[0]->getType() == mShG->mFP32Ty)
            {
                aggType = mShG->mV4FP32Ty;
            }
            if (vargs[0]->getType() == mShG->mInt32Ty)
            {
                aggType = mShG->mV4Int32Ty;
            }
            result = mShG->mBuilder.CreateInsertValue(UndefValue::get(aggType), vargs[0], std::vector<UINT>(1, 0));
            for (UINT i = 1; i < 4; ++i)
            {
                result = mShG->mBuilder.CreateInsertValue(result, vargs[i], std::vector<UINT>(1, i));
            }
        }
        break;
        case SWRC_GETELT:
            result = mShG->mBuilder.CreateExtractValue(vargs[0], std::vector<UINT>(1, (UINT)args[1]));
            break;
        case SWRC_SETELT:
            result = mShG->mBuilder.CreateInsertValue(vargs[0], vargs[2], std::vector<UINT>(1, (UINT)args[1]));
            break;
        default:
            assert(false);
            break;
        }

        Value *cell = 0;
        SWRC_WORDCODE name = SWRC_NOT_A_TOKEN;
        if (hasDest)
        {
            name = args[0];
            cell = mRegMap[name];
        }
        else
        {
            name = GetFreshVar();
            mShG->mBuilder.SetInsertPoint(mProlog);
            cell = mShG->mBuilder.CreateAlloca(result->getType());
            mRegMap[name] = cell;
            ResetCurrentBlock();
        }

        mShG->mBuilder.CreateStore(result, cell);

#if defined(KNOB_SWRC_TRACING)
        fprintf(mpLogFile, " r%-4d :=", name);
        for (UINT i = 0, N = args.size(); i < N; ++i)
        {
            fprintf(mpLogFile, " r%-4d", args[i]);
        }
        fprintf(mpLogFile, "%s", "\n");
#endif

        return name;
    }

    ShG *mShG;
    SWR_SHADER_TYPE mShaderType;

    Function *mFunction;
    BasicBlock *mProlog;
    BasicBlock *mEpilog;
    BasicBlock *mEntry;
    BasicBlock *mCurrent;
    std::map<SWRC_WORDCODE, BasicBlock *> mBlockMap;

    Value *mPIn;
    Value *mPOut;
    Value *mPConstAddr;
    Value *mPConstOpaque;
    Value *mPConst;

    SWRC_WORDCODE mFreshVarName;
    std::map<SWRC_WORDCODE, Value *> mRegMap;
    std::map<UINT, Value *> mOutputSlotMap;
    std::vector<DECL> mInputSlots;
    std::vector<DECL> mOutputSlots;

    bool mCompactOutputs;
    bool mDoPerspective;
    bool mHorizontal;
    UINT mXIterations;
    UINT mYIterations;
    MDNode *mSimtizeGEPBC;
    MDNode *mSimtizeLoad;

#if defined(KNOB_SWRC_TRACING)
    FILE *mpLogFile;
#endif
};

struct SWRC_TEXTURE_SAMPLE_INSTR_GEN
{
    SWRC_TEXTURE_SAMPLE_INSTR_GEN(ShG *pCompiler, HANDLE hTx, HANDLE hTxV, HANDLE hSmp)
    {
        mShG = pCompiler;
        mhTx = hTx;
        mhTxV = hTxV;
        mhSmp = hSmp;
    }

    PFN_TEXTURE_SAMPLE_INSTR MakeTextureSampleInstruction()
    {
        // void(SWRC_TEXTURE_VIEW*, SWRC_TEXCOORD*, SWRC_MIPS*, SWRC_COLOR*);
        //				in				in				in			out
        return 0;
    }

    ShG *mShG;
    HANDLE mhTx;
    HANDLE mhTxV;
    HANDLE mhSmp;
};

HANDLE swrcCreateCompiler(UINT scalarizedWidth)
{
    return new ShG(scalarizedWidth);
}

void swrcDestroyCompiler(HANDLE hCompiler)
{
    delete reinterpret_cast<ShG *>(hCompiler);
}

PFN_FETCH_FUNC swrcCreateFetchShader(HANDLE hCompiler, HANDLE hContext, UINT numElements, INPUT_ELEMENT_DESC (&inputLayout)[KNOB_NUM_ATTRIBUTES], UINT (&inputStrides)[KNOB_NUM_STREAMS], SWRC_WORDCODE contiguity, SWR_TYPE indexType)
{
    reinterpret_cast<ShG *>(hCompiler)->InitializeModule();
    SWRC_FETCHGEN fsGen(reinterpret_cast<ShG *>(hCompiler), hContext, numElements, inputLayout, inputStrides, contiguity, indexType);
    return fsGen.MakePackingFetchShader();
}

PFN_TEXTURE_SAMPLE_INSTR swrcCreateTextureSampleInstruction(HANDLE hCompiler, HANDLE hTx, HANDLE hTxV, HANDLE hSmp)
{
    SWRC_TEXTURE_SAMPLE_INSTR_GEN tsiGen(reinterpret_cast<ShG *>(hCompiler), hTx, hTxV, hSmp);
    return tsiGen.MakeTextureSampleInstruction();
}

SWRC_ASM *swrcCreateAssembler(HANDLE hCompiler, SWR_SHADER_TYPE sType)
{
    reinterpret_cast<ShG *>(hCompiler)->InitializeModule();
    return new SWRC_ASM(reinterpret_cast<ShG *>(hCompiler), sType);
}

void swrcDestroyAssembler(SWRC_ASM *&pAsm)
{
    delete pAsm;
    pAsm = 0;
}

void swrcSetTracing(SWRC_ASM *pAsm, FILE *pLogFile)
{
#if defined(KNOB_SWRC_TRACING)
    pAsm->mpLogFile = pLogFile;
#endif
}

HANDLE swrcAssemble(SWRC_ASM *pAsm)
{
    return pAsm->Assemble();
}

HANDLE swrcAssembleWith(SWRC_ASM *pAsm, UINT numOutSlots, const UINT *outSlots)
{
    return pAsm->Assemble(numOutSlots, outSlots);
}

void swrcAddNote(SWRC_ASM *pAsm, const char *pNote)
{
#if defined(KNOB_SWRC_TRACING)
    fprintf(pAsm->mpLogFile, "; %s\n", pNote);
#endif
}

void swrcSetOption(SWRC_ASM *pAsm, SWRC_WORDCODE option)
{
    pAsm->SetOption(option, 0, 0);
}

void swrcSetOption(SWRC_ASM *pAsm, SWRC_WORDCODE option, UINT a)
{
    pAsm->SetOption(option, a, 0);
}

void swrcSetOption(SWRC_ASM *pAsm, SWRC_WORDCODE option, UINT a, UINT b)
{
    pAsm->SetOption(option, a, b);
}

SWRC_WORDCODE swrcAddDecl(SWRC_ASM *pAsm, UINT slot, SWRC_WORDCODE inOrOut)
{
    return pAsm->AddDecl(slot, inOrOut, SWRC_V4FP32, 4);
}

SWRC_WORDCODE swrcAddDecl(SWRC_ASM *pAsm, UINT slot, SWRC_WORDCODE inOrOut, SWRC_WORDCODE type)
{
    return pAsm->AddDecl(slot, inOrOut, type, 4);
}

SWRC_WORDCODE swrcAddDecl(SWRC_ASM *pAsm, UINT slot, SWRC_WORDCODE inOrOut, UINT subSet)
{
    return pAsm->AddDecl(slot, inOrOut, SWRC_V4FP32, subSet);
}

SWRC_WORDCODE swrcAddConstant(SWRC_ASM *pAsm, UINT byteOffset, SWRC_WORDCODE type)
{
    return pAsm->AddConstant(byteOffset, type);
}

SWRC_WORDCODE swrcAddImm(SWRC_ASM *pAsm, UINT val)
{
    return pAsm->AddImm(val);
}

SWRC_WORDCODE swrcAddImm(SWRC_ASM *pAsm, UINT v0, UINT v1, UINT v2, UINT v3)
{
    return pAsm->AddImm(v0, v1, v2, v3);
}

SWRC_WORDCODE swrcAddImm(SWRC_ASM *pAsm, float val)
{
    return pAsm->AddImm(val);
}

SWRC_WORDCODE swrcAddImm(SWRC_ASM *pAsm, float v0, float v1, float v2, float v3)
{
    return pAsm->AddImm(v0, v1, v2, v3);
}

SWRC_WORDCODE swrcAddBlock(SWRC_ASM *pAsm)
{
    return pAsm->AddBlock();
}

void swrcSetEntryBlock(SWRC_ASM *pAsm, SWRC_WORDCODE block)
{
    return pAsm->SetEntryBlock(block);
}

void swrcSetCurrentBlock(SWRC_ASM *pAsm, SWRC_WORDCODE block)
{
    return pAsm->SetCurrentBlock(block);
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op)
{
    return pAsm->AddInstruction(op, std::vector<SWRC_WORDCODE>());
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op, SWRC_WORDCODE arg0)
{
    return pAsm->AddInstruction(op, std::vector<SWRC_WORDCODE>(1, arg0));
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op, SWRC_WORDCODE arg0, SWRC_WORDCODE arg1)
{
    SWRC_WORDCODE args[] = { arg0, arg1 };
    return pAsm->AddInstruction(op, std::vector<SWRC_WORDCODE>(&args[0], &args[0] + sizeof(args) / sizeof(args[0])));
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op, SWRC_WORDCODE arg0, SWRC_WORDCODE arg1, SWRC_WORDCODE arg2)
{
    SWRC_WORDCODE args[] = { arg0, arg1, arg2 };
    return pAsm->AddInstruction(op, std::vector<SWRC_WORDCODE>(&args[0], &args[0] + sizeof(args) / sizeof(args[0])));
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op, SWRC_WORDCODE arg0, SWRC_WORDCODE arg1, SWRC_WORDCODE arg2, SWRC_WORDCODE arg3)
{
    SWRC_WORDCODE args[] = { arg0, arg1, arg2, arg3 };
    return pAsm->AddInstruction(op, std::vector<SWRC_WORDCODE>(&args[0], &args[0] + sizeof(args) / sizeof(args[0])));
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op, SWRC_WORDCODE arg0, SWRC_WORDCODE arg1, SWRC_WORDCODE arg2, SWRC_WORDCODE arg3, SWRC_WORDCODE arg4)
{
    SWRC_WORDCODE args[] = { arg0, arg1, arg2, arg3, arg4 };
    return pAsm->AddInstruction(op, std::vector<SWRC_WORDCODE>(&args[0], &args[0] + sizeof(args) / sizeof(args[0])));
}

SWRC_WORDCODE swrcAddInstr(SWRC_ASM *pAsm, SWRC_WORDCODE op, std::vector<SWRC_WORDCODE> const &args)
{
    assert((op < SWRC_LAST_TOKEN) && "Not a valid op-code!");
    return pAsm->AddInstruction(op, args);
}
